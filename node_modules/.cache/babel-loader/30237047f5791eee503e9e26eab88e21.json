{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // based on http://www.compix.com/fileformattif.htm\n// TO-DO: support big-endian as well\n\nconst fs = require(\"fs\");\n\nconst readUInt_1 = require(\"../readUInt\"); // Read IFD (image-file-directory) into a buffer\n\n\nfunction readIFD(buffer, filepath, isBigEndian) {\n  const ifdOffset = readUInt_1.readUInt(buffer, 32, 4, isBigEndian); // read only till the end of the file\n\n  let bufferSize = 1024;\n  const fileSize = fs.statSync(filepath).size;\n\n  if (ifdOffset + bufferSize > fileSize) {\n    bufferSize = fileSize - ifdOffset - 10;\n  } // populate the buffer\n\n\n  const endBuffer = Buffer.alloc(bufferSize);\n  const descriptor = fs.openSync(filepath, 'r');\n  fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);\n  return endBuffer.slice(2);\n} // TIFF values seem to be messed up on Big-Endian, this helps\n\n\nfunction readValue(buffer, isBigEndian) {\n  const low = readUInt_1.readUInt(buffer, 16, 8, isBigEndian);\n  const high = readUInt_1.readUInt(buffer, 16, 10, isBigEndian);\n  return (high << 16) + low;\n} // move to the next tag\n\n\nfunction nextTag(buffer) {\n  if (buffer.length > 24) {\n    return buffer.slice(12);\n  }\n} // Extract IFD tags from TIFF metadata\n\n\nfunction extractTags(buffer, isBigEndian) {\n  const tags = {};\n  let temp = buffer;\n\n  while (temp && temp.length) {\n    const code = readUInt_1.readUInt(temp, 16, 0, isBigEndian);\n    const type = readUInt_1.readUInt(temp, 16, 2, isBigEndian);\n    const length = readUInt_1.readUInt(temp, 32, 4, isBigEndian); // 0 means end of IFD\n\n    if (code === 0) {\n      break;\n    } else {\n      // 256 is width, 257 is height\n      // if (code === 256 || code === 257) {\n      if (length === 1 && (type === 3 || type === 4)) {\n        tags[code] = readValue(temp, isBigEndian);\n      } // move to the next tag\n\n\n      temp = nextTag(temp);\n    }\n  }\n\n  return tags;\n} // Test if the TIFF is Big Endian or Little Endian\n\n\nfunction determineEndianness(buffer) {\n  const signature = buffer.toString('ascii', 0, 2);\n\n  if ('II' === signature) {\n    return 'LE';\n  } else if ('MM' === signature) {\n    return 'BE';\n  }\n}\n\nconst signatures = [// '492049', // currently not supported\n'49492a00', '4d4d002a'];\nexports.TIFF = {\n  validate(buffer) {\n    return signatures.includes(buffer.toString('hex', 0, 4));\n  },\n\n  calculate(buffer, filepath) {\n    if (!filepath) {\n      throw new TypeError('Tiff doesn\\'t support buffer');\n    } // Determine BE/LE\n\n\n    const isBigEndian = determineEndianness(buffer) === 'BE'; // read the IFD\n\n    const ifdBuffer = readIFD(buffer, filepath, isBigEndian); // extract the tags from the IFD\n\n    const tags = extractTags(ifdBuffer, isBigEndian);\n    const width = tags[256];\n    const height = tags[257];\n\n    if (!width || !height) {\n      throw new TypeError('Invalid Tiff. Missing tags');\n    }\n\n    return {\n      height,\n      width\n    };\n  }\n\n};","map":{"version":3,"sources":["E:/PROJECT/WEB/sebgnd-photography/front-end/node_modules/image-size/dist/types/tiff.js"],"names":["Object","defineProperty","exports","value","fs","require","readUInt_1","readIFD","buffer","filepath","isBigEndian","ifdOffset","readUInt","bufferSize","fileSize","statSync","size","endBuffer","Buffer","alloc","descriptor","openSync","readSync","slice","readValue","low","high","nextTag","length","extractTags","tags","temp","code","type","determineEndianness","signature","toString","signatures","TIFF","validate","includes","calculate","TypeError","ifdBuffer","width","height"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// based on http://www.compix.com/fileformattif.htm\n// TO-DO: support big-endian as well\nconst fs = require(\"fs\");\nconst readUInt_1 = require(\"../readUInt\");\n// Read IFD (image-file-directory) into a buffer\nfunction readIFD(buffer, filepath, isBigEndian) {\n    const ifdOffset = readUInt_1.readUInt(buffer, 32, 4, isBigEndian);\n    // read only till the end of the file\n    let bufferSize = 1024;\n    const fileSize = fs.statSync(filepath).size;\n    if (ifdOffset + bufferSize > fileSize) {\n        bufferSize = fileSize - ifdOffset - 10;\n    }\n    // populate the buffer\n    const endBuffer = Buffer.alloc(bufferSize);\n    const descriptor = fs.openSync(filepath, 'r');\n    fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);\n    return endBuffer.slice(2);\n}\n// TIFF values seem to be messed up on Big-Endian, this helps\nfunction readValue(buffer, isBigEndian) {\n    const low = readUInt_1.readUInt(buffer, 16, 8, isBigEndian);\n    const high = readUInt_1.readUInt(buffer, 16, 10, isBigEndian);\n    return (high << 16) + low;\n}\n// move to the next tag\nfunction nextTag(buffer) {\n    if (buffer.length > 24) {\n        return buffer.slice(12);\n    }\n}\n// Extract IFD tags from TIFF metadata\nfunction extractTags(buffer, isBigEndian) {\n    const tags = {};\n    let temp = buffer;\n    while (temp && temp.length) {\n        const code = readUInt_1.readUInt(temp, 16, 0, isBigEndian);\n        const type = readUInt_1.readUInt(temp, 16, 2, isBigEndian);\n        const length = readUInt_1.readUInt(temp, 32, 4, isBigEndian);\n        // 0 means end of IFD\n        if (code === 0) {\n            break;\n        }\n        else {\n            // 256 is width, 257 is height\n            // if (code === 256 || code === 257) {\n            if (length === 1 && (type === 3 || type === 4)) {\n                tags[code] = readValue(temp, isBigEndian);\n            }\n            // move to the next tag\n            temp = nextTag(temp);\n        }\n    }\n    return tags;\n}\n// Test if the TIFF is Big Endian or Little Endian\nfunction determineEndianness(buffer) {\n    const signature = buffer.toString('ascii', 0, 2);\n    if ('II' === signature) {\n        return 'LE';\n    }\n    else if ('MM' === signature) {\n        return 'BE';\n    }\n}\nconst signatures = [\n    // '492049', // currently not supported\n    '49492a00',\n    '4d4d002a',\n];\nexports.TIFF = {\n    validate(buffer) {\n        return signatures.includes(buffer.toString('hex', 0, 4));\n    },\n    calculate(buffer, filepath) {\n        if (!filepath) {\n            throw new TypeError('Tiff doesn\\'t support buffer');\n        }\n        // Determine BE/LE\n        const isBigEndian = determineEndianness(buffer) === 'BE';\n        // read the IFD\n        const ifdBuffer = readIFD(buffer, filepath, isBigEndian);\n        // extract the tags from the IFD\n        const tags = extractTags(ifdBuffer, isBigEndian);\n        const width = tags[256];\n        const height = tags[257];\n        if (!width || !height) {\n            throw new TypeError('Invalid Tiff. Missing tags');\n        }\n        return { height, width };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}