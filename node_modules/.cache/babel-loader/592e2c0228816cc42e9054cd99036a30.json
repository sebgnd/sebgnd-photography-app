{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction calculateExtended(buffer) {\n  return {\n    height: 1 + buffer.readUIntLE(7, 3),\n    width: 1 + buffer.readUIntLE(4, 3)\n  };\n}\n\nfunction calculateLossless(buffer) {\n  return {\n    height: 1 + ((buffer[4] & 0xF) << 10 | buffer[3] << 2 | (buffer[2] & 0xC0) >> 6),\n    width: 1 + ((buffer[2] & 0x3F) << 8 | buffer[1])\n  };\n}\n\nfunction calculateLossy(buffer) {\n  // `& 0x3fff` returns the last 14 bits\n  // TO-DO: include webp scaling in the calculations\n  return {\n    height: buffer.readInt16LE(8) & 0x3fff,\n    width: buffer.readInt16LE(6) & 0x3fff\n  };\n}\n\nexports.WEBP = {\n  validate(buffer) {\n    const riffHeader = 'RIFF' === buffer.toString('ascii', 0, 4);\n    const webpHeader = 'WEBP' === buffer.toString('ascii', 8, 12);\n    const vp8Header = 'VP8' === buffer.toString('ascii', 12, 15);\n    return riffHeader && webpHeader && vp8Header;\n  },\n\n  calculate(buffer) {\n    const chunkHeader = buffer.toString('ascii', 12, 16);\n    buffer = buffer.slice(20, 30); // Extended webp stream signature\n\n    if (chunkHeader === 'VP8X') {\n      const extendedHeader = buffer[0];\n      const validStart = (extendedHeader & 0xc0) === 0;\n      const validEnd = (extendedHeader & 0x01) === 0;\n\n      if (validStart && validEnd) {\n        return calculateExtended(buffer);\n      } else {\n        // TODO: breaking change\n        throw new TypeError('Invalid WebP');\n      }\n    } // Lossless webp stream signature\n\n\n    if (chunkHeader === 'VP8 ' && buffer[0] !== 0x2f) {\n      return calculateLossy(buffer);\n    } // Lossy webp stream signature\n\n\n    const signature = buffer.toString('hex', 3, 6);\n\n    if (chunkHeader === 'VP8L' && signature !== '9d012a') {\n      return calculateLossless(buffer);\n    }\n\n    throw new TypeError('Invalid WebP');\n  }\n\n};","map":{"version":3,"sources":["E:/PROJECT/WEB/sebgnd-photography/front-end/node_modules/image-size/dist/types/webp.js"],"names":["Object","defineProperty","exports","value","calculateExtended","buffer","height","readUIntLE","width","calculateLossless","calculateLossy","readInt16LE","WEBP","validate","riffHeader","toString","webpHeader","vp8Header","calculate","chunkHeader","slice","extendedHeader","validStart","validEnd","TypeError","signature"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction calculateExtended(buffer) {\n    return {\n        height: 1 + buffer.readUIntLE(7, 3),\n        width: 1 + buffer.readUIntLE(4, 3)\n    };\n}\nfunction calculateLossless(buffer) {\n    return {\n        height: 1 + (((buffer[4] & 0xF) << 10) | (buffer[3] << 2) | ((buffer[2] & 0xC0) >> 6)),\n        width: 1 + (((buffer[2] & 0x3F) << 8) | buffer[1])\n    };\n}\nfunction calculateLossy(buffer) {\n    // `& 0x3fff` returns the last 14 bits\n    // TO-DO: include webp scaling in the calculations\n    return {\n        height: buffer.readInt16LE(8) & 0x3fff,\n        width: buffer.readInt16LE(6) & 0x3fff\n    };\n}\nexports.WEBP = {\n    validate(buffer) {\n        const riffHeader = 'RIFF' === buffer.toString('ascii', 0, 4);\n        const webpHeader = 'WEBP' === buffer.toString('ascii', 8, 12);\n        const vp8Header = 'VP8' === buffer.toString('ascii', 12, 15);\n        return (riffHeader && webpHeader && vp8Header);\n    },\n    calculate(buffer) {\n        const chunkHeader = buffer.toString('ascii', 12, 16);\n        buffer = buffer.slice(20, 30);\n        // Extended webp stream signature\n        if (chunkHeader === 'VP8X') {\n            const extendedHeader = buffer[0];\n            const validStart = (extendedHeader & 0xc0) === 0;\n            const validEnd = (extendedHeader & 0x01) === 0;\n            if (validStart && validEnd) {\n                return calculateExtended(buffer);\n            }\n            else {\n                // TODO: breaking change\n                throw new TypeError('Invalid WebP');\n            }\n        }\n        // Lossless webp stream signature\n        if (chunkHeader === 'VP8 ' && buffer[0] !== 0x2f) {\n            return calculateLossy(buffer);\n        }\n        // Lossy webp stream signature\n        const signature = buffer.toString('hex', 3, 6);\n        if (chunkHeader === 'VP8L' && signature !== '9d012a') {\n            return calculateLossless(buffer);\n        }\n        throw new TypeError('Invalid WebP');\n    }\n};\n"]},"metadata":{},"sourceType":"script"}