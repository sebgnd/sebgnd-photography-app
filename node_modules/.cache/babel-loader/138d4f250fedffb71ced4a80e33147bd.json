{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst PNMTypes = {\n  P1: 'pbm/ascii',\n  P2: 'pgm/ascii',\n  P3: 'ppm/ascii',\n  P4: 'pbm',\n  P5: 'pgm',\n  P6: 'ppm',\n  P7: 'pam',\n  PF: 'pfm'\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n  default: lines => {\n    let dimensions = [];\n\n    while (lines.length > 0) {\n      const line = lines.shift();\n\n      if (line[0] === '#') {\n        continue;\n      }\n\n      dimensions = line.split(' ');\n      break;\n    }\n\n    if (dimensions.length === 2) {\n      return {\n        height: parseInt(dimensions[1], 10),\n        width: parseInt(dimensions[0], 10)\n      };\n    } else {\n      throw new TypeError('Invalid PNM');\n    }\n  },\n  pam: lines => {\n    const size = {};\n\n    while (lines.length > 0) {\n      const line = lines.shift();\n\n      if (line.length > 16 || line.charCodeAt(0) > 128) {\n        continue;\n      }\n\n      const [key, value] = line.split(' ');\n\n      if (key && value) {\n        size[key.toLowerCase()] = parseInt(value, 10);\n      }\n\n      if (size.height && size.width) {\n        break;\n      }\n    }\n\n    if (size.height && size.width) {\n      return {\n        height: size.height,\n        width: size.width\n      };\n    } else {\n      throw new TypeError('Invalid PAM');\n    }\n  }\n};\nexports.PNM = {\n  validate(buffer) {\n    const signature = buffer.toString('ascii', 0, 2);\n    return Signatures.includes(signature);\n  },\n\n  calculate(buffer) {\n    const signature = buffer.toString('ascii', 0, 2);\n    const type = PNMTypes[signature]; // TODO: this probably generates garbage. move to a stream based parser\n\n    const lines = buffer.toString('ascii', 3).split(/[\\r\\n]+/);\n    const handler = handlers[type] || handlers.default;\n    return handler(lines);\n  }\n\n};","map":{"version":3,"sources":["E:/PROJECT/WEB/sebgnd-photography/front-end/node_modules/image-size/dist/types/pnm.js"],"names":["Object","defineProperty","exports","value","PNMTypes","P1","P2","P3","P4","P5","P6","P7","PF","Signatures","keys","handlers","default","lines","dimensions","length","line","shift","split","height","parseInt","width","TypeError","pam","size","charCodeAt","key","toLowerCase","PNM","validate","buffer","signature","toString","includes","calculate","type","handler"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PNMTypes = {\n    P1: 'pbm/ascii',\n    P2: 'pgm/ascii',\n    P3: 'ppm/ascii',\n    P4: 'pbm',\n    P5: 'pgm',\n    P6: 'ppm',\n    P7: 'pam',\n    PF: 'pfm'\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n    default: (lines) => {\n        let dimensions = [];\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line[0] === '#') {\n                continue;\n            }\n            dimensions = line.split(' ');\n            break;\n        }\n        if (dimensions.length === 2) {\n            return {\n                height: parseInt(dimensions[1], 10),\n                width: parseInt(dimensions[0], 10),\n            };\n        }\n        else {\n            throw new TypeError('Invalid PNM');\n        }\n    },\n    pam: (lines) => {\n        const size = {};\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line.length > 16 || line.charCodeAt(0) > 128) {\n                continue;\n            }\n            const [key, value] = line.split(' ');\n            if (key && value) {\n                size[key.toLowerCase()] = parseInt(value, 10);\n            }\n            if (size.height && size.width) {\n                break;\n            }\n        }\n        if (size.height && size.width) {\n            return {\n                height: size.height,\n                width: size.width\n            };\n        }\n        else {\n            throw new TypeError('Invalid PAM');\n        }\n    }\n};\nexports.PNM = {\n    validate(buffer) {\n        const signature = buffer.toString('ascii', 0, 2);\n        return Signatures.includes(signature);\n    },\n    calculate(buffer) {\n        const signature = buffer.toString('ascii', 0, 2);\n        const type = PNMTypes[signature];\n        // TODO: this probably generates garbage. move to a stream based parser\n        const lines = buffer.toString('ascii', 3).split(/[\\r\\n]+/);\n        const handler = handlers[type] || handlers.default;\n        return handler(lines);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}